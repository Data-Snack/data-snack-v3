import { NextRequest, NextResponse } from 'next/server';\nimport { ServerTracker } from '@data-snack/tracking';\nimport { TrackingEvent } from '@data-snack/core';\nimport { z } from 'zod';\n\n// Consent request schema\nconst ConsentRequestSchema = z.object({\n  userId: z.string().optional(),\n  sessionId: z.string(),\n  consent: z.object({\n    necessary: z.boolean().default(true),\n    analytics: z.boolean(),\n    marketing: z.boolean(),\n    personalization: z.boolean(),\n  }),\n  timestamp: z.string().datetime().optional(),\n  ipAddress: z.string().optional(),\n});\n\nconst tracker = new ServerTracker({\n  enableDatabase: true,\n  debug: process.env.NODE_ENV === 'development',\n});\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': process.env.NODE_ENV === 'development' \n    ? '*' \n    : 'https://data-snack.com',\n  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type',\n};\n\nexport async function OPTIONS() {\n  return new NextResponse(null, {\n    status: 204,\n    headers: corsHeaders,\n  });\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { userId, sessionId, consent, timestamp } = ConsentRequestSchema.parse(body);\n    \n    // Get client IP\n    const forwarded = request.headers.get('x-forwarded-for');\n    const realIp = request.headers.get('x-real-ip');\n    const clientIp = forwarded?.split(',')[0] || realIp || 'unknown';\n    \n    // Create consent change event\n    const consentEvent = TrackingEvent.create(\n      'consent_change',\n      'consent_updated',\n      {\n        consent,\n        timestamp: timestamp || new Date().toISOString(),\n        ipAddress: clientIp,\n        userAgent: request.headers.get('user-agent'),\n      },\n      {\n        userAgent: request.headers.get('user-agent') || 'Unknown',\n        ip: clientIp,\n      }\n    ).withSession(sessionId);\n    \n    if (userId) {\n      consentEvent.withUser(userId as any);\n    }\n    \n    // Track the consent change\n    await tracker.track(consentEvent);\n    \n    // Return success response\n    return NextResponse.json(\n      { \n        success: true,\n        message: 'Consent preferences updated',\n        timestamp: new Date().toISOString(),\n      },\n      {\n        status: 200,\n        headers: corsHeaders,\n      }\n    );\n    \n  } catch (error) {\n    console.error('[API] Consent error:', error);\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { \n          error: 'Invalid consent data',\n          details: error.errors,\n        },\n        { \n          status: 400,\n          headers: corsHeaders,\n        }\n      );\n    }\n    \n    return NextResponse.json(\n      { error: 'Failed to update consent' },\n      { \n        status: 500,\n        headers: corsHeaders,\n      }\n    );\n  }\n}\n\n// Get current consent status (if we store it per user)\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const userId = searchParams.get('userId');\n  const sessionId = searchParams.get('sessionId');\n  \n  if (!sessionId) {\n    return NextResponse.json(\n      { error: 'Session ID required' },\n      { status: 400, headers: corsHeaders }\n    );\n  }\n  \n  // In a real implementation, you'd fetch from database\n  // For now, return default consent state\n  const defaultConsent = {\n    necessary: true,\n    analytics: false,\n    marketing: false,\n    personalization: false,\n  };\n  \n  return NextResponse.json(\n    {\n      consent: defaultConsent,\n      userId: userId || null,\n      sessionId,\n      timestamp: new Date().toISOString(),\n    },\n    {\n      headers: corsHeaders,\n    }\n  );\n}\n